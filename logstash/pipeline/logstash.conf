input {
  # Generate one event every 30 seconds
  heartbeat {
    interval => 30
    message  => "simulate_traffic"
  }
}

filter {
  #
  # 1) Generate RANDOM feature values for each event
  #
  ruby {
    code => '
      # Random source/dest ports
      sport = rand(1024..65535)
      common_dports = [22, 80, 443, 3389, 8080]
      dsport = common_dports.sample

      # Random protocol: 6 = TCP, 17 = UDP
      proto = [6, 17].sample

      # Duration between 0.1 and 10.0 seconds
      dur = (rand * 9.9 + 0.1).round(2)

      # Bytes (make dbytes >= sbytes so it looks realistic)
      sbytes = rand(50..5000)
      dbytes = sbytes + rand(0..20000)

      # TTL values (typical-ish ranges)
      sttl = [32, 64, 128].sample
      dttl = [32, 64, 128].sample

      # Connection state TTL-like feature
      ct_state_ttl = rand(1..10)

      event.set("sport", sport)
      event.set("dsport", dsport)
      event.set("proto", proto)
      event.set("dur", dur)
      event.set("sbytes", sbytes)
      event.set("dbytes", dbytes)
      event.set("sttl", sttl)
      event.set("dttl", dttl)
      event.set("ct_state_ttl", ct_state_ttl)
    '
  }

  #
  # 2) Build JSON STRING for FastAPI request
  #
  mutate {
    add_field => {
      "request_body" => '{
        "sport": "%{sport}",
        "dsport": "%{dsport}",
        "proto": "%{proto}",
        "dur": "%{dur}",
        "sbytes": "%{sbytes}",
        "dbytes": "%{dbytes}",
        "sttl": "%{sttl}",
        "dttl": "%{dttl}",
        "ct_state_ttl": "%{ct_state_ttl}"
      }'
    }
  }

  #
  # 3) Call FastAPI ML model
  #
  http {
    url  => "http://host.docker.internal:8000/predict"
    verb => "POST"
    body => "%{request_body}"
    target_body => "api_response"
    headers => {
      "Content-Type" => "application/json"
    }
  }

  #
  # 4) Copy ML results into top-level fields
  #
  mutate {
    add_field => {
      "ml_label"       => "%{[api_response][label]}"
      "ml_probability" => "%{[api_response][probability]}"
    }
  }

  #
  # 5) Compute severity from ml_probability
  #
  ruby {
    code => '
      prob_val = event.get("ml_probability")
      prob = nil

      if prob_val
        begin
          prob = prob_val.to_f
        rescue
          prob = nil
        end
      end

      if prob.nil?
        event.set("ml_severity", "unknown")
      elsif prob >= 0.90
        event.set("ml_severity", "critical")
      elsif prob >= 0.70
        event.set("ml_severity", "high")
      elsif prob >= 0.40
        event.set("ml_severity", "medium")
      else
        event.set("ml_severity", "low")
      end
    '
  }

  #
  # 6) Convert types & cleanup
  #
  mutate {
    convert => {
      "ml_label"       => "integer"
      "ml_probability" => "float"
      "sport"          => "integer"
      "dsport"         => "integer"
      "proto"          => "integer"
      "dur"            => "float"
      "sbytes"         => "integer"
      "dbytes"         => "integer"
      "sttl"           => "integer"
      "dttl"           => "integer"
      "ct_state_ttl"   => "integer"
    }
    remove_field => ["api_response", "request_body", "headers", "message"]
  }
}

output {
  elasticsearch {
    hosts => [ "http://elasticsearch:9200" ]
    index => "ml_ids_alerts"
  }

  stdout { codec => rubydebug }
}
